<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Russisch Vokabeltrainer</title>
    <style>
        :root {
            /* Gr√ºnes Farbschema */
            --primary-color: #2e7d32; /* Dunkelgr√ºn */
            --primary-light: #60ad5e; /* Hellgr√ºn */
            --primary-dark: #005005; /* Sehr dunkles Gr√ºn */
            --accent-color: #a5d6a7; /* Akzent */
            --bg-color: #e8f5e9;     /* Hintergrund */
            --text-color: #1b5e20;   /* Textfarbe */
            --card-bg: #ffffff;
            --shadow: 0 4px 10px rgba(0,0,0,0.15);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            justify-content: center;
        }

        .container {
            width: 90%;
            max-width: 600px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        h1 {
            margin: 0;
            color: var(--primary-dark);
            text-align: center;
            font-size: 1.8rem;
        }

        /* Fortschrittsanzeige */
        .progress-container {
            background: #c8e6c9;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9rem;
            color: var(--primary-dark);
        }

        /* Karten-Szene (f√ºr 3D Effekt) */
        .scene {
            width: 100%;
            height: 300px;
            perspective: 1000px;
            cursor: pointer;
        }

        /* Die Karte selbst */
        .card {
            width: 100%;
            height: 100%;
            position: relative;
            transition: transform 0.6s;
            transform-style: preserve-3d;
            border-radius: 15px;
            box-shadow: var(--shadow);
        }

        .card.is-flipped {
            transform: rotateY(180deg);
        }

        /* Vorder- und R√ºckseite */
        .card__face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            border-radius: 15px;
            padding: 20px;
            box-sizing: border-box;
            background-color: var(--card-bg);
            border: 2px solid var(--primary-light);
            text-align: center;
        }

        .card__face--front {
            /* Standardseite */
        }

        .card__face--back {
            transform: rotateY(180deg);
            background-color: #f1f8e9; /* Leicht anderer Hintergrund f√ºr R√ºckseite */
            border-color: var(--primary-color);
        }

        /* Textstyling auf der Karte */
        .vocab-word {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }

        .vocab-note {
            font-size: 1rem;
            color: #666;
            font-style: italic;
        }

        /* Hinweis zum Drehen */
        .flip-hint {
            position: absolute;
            bottom: 10px;
            font-size: 0.75rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Steuerungs-Buttons */
        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            width: 100%;
        }

        .btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
            display: flex;
            align-items: center;
            gap: 5px;
            min-width: 44px; /* Touch target size */
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .btn:hover {
            background-color: var(--primary-light);
        }

        .btn:active {
            transform: scale(0.98);
        }

        .btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            box-shadow: none;
        }

        .btn-secondary {
            background-color: var(--accent-color);
            color: var(--primary-dark);
        }
        .btn-secondary:hover {
            background-color: #dcedc8;
        }

        /* Keyboard Info Footer */
        .keyboard-info {
            margin-top: 20px;
            font-size: 0.8rem;
            color: #777;
            text-align: center;
        }

        .key-badge {
            display: inline-block;
            background: #eee;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 2px 6px;
            margin: 0 2px;
            font-family: monospace;
            font-size: 0.9em;
        }

        /* Responsives Design */
        @media (max-width: 600px) {
            .scene {
                height: 250px;
            }
            .vocab-word {
                font-size: 1.5rem;
            }
            .btn span {
                /* Text auf sehr kleinen Bildschirmen bei Pfeilen ausblenden optional */
            }
            .controls {
                gap: 8px;
            }
            .btn {
                padding: 10px 15px;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>Russische Verben & Nomen</h1>
        
        <div class="progress-container">
            Karte <span id="current-index">1</span> von <span id="total-count">35</span>
        </div>

        <div class="scene">
            <div class="card" id="flashcard">
                <div class="card__face card__face--front">
                    <div class="vocab-word" id="front-text">Laden...</div>
                    <div class="vocab-note" id="front-note"></div>
                    <div class="flip-hint">Klicken zum Wenden</div>
                </div>
                <div class="card__face card__face--back">
                    <div class="vocab-word" id="back-text"></div>
                    <div class="vocab-note" id="back-note"></div>
                    <div class="flip-hint">Klicken zum Wenden</div>
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="btn" id="btn-prev" aria-label="Vorherige Karte">‚Üê Vorherige</button>
            <button class="btn" id="btn-next" aria-label="N√§chste Karte">N√§chste ‚Üí</button>
        </div>

        <div class="controls">
            <button class="btn btn-secondary" id="btn-reset" aria-label="An den Anfang">‚Ü∫ Anfang</button>
            <button class="btn btn-secondary" id="btn-shuffle" aria-label="Mischen">üîÄ Mischen</button>
        </div>

        <div class="keyboard-info">
            Tastatur: <span class="key-badge">Leertaste</span> / <span class="key-badge">Enter</span> zum Wenden, 
            <span class="key-badge">‚Üê</span> / <span class="key-badge">‚Üí</span> zur Navigation
        </div>
    </div>

    <script>
        // --- Daten ---
        const rawVocabulary = [
            "1.	—Å—Ç–∞ÃÅ–≤–∏—Ç—å / –ø–æ—Å—Ç–∞ÃÅ–≤–∏—Ç—å ‚Äì stellen",
            "2.	–∫–ª–∞—Å—Ç—å / –ø–æ–ª–æ–∂–∏ÃÅ—Ç—å ‚Äì legen",
            "3.	–≤–µÃÅ—à–∞—Ç—å / –ø–æ–≤–µÃÅ—Å–∏—Ç—å ‚Äì h√§ngen (Aktion: aufh√§ngen)",
            "4.	—Å—Ç–æ—èÃÅ—Ç—å ‚Äì stehen",
            "5.	–ª–µ–∂–∞ÃÅ—Ç—å ‚Äì liegen",
            "6.	–≤–∏—Å–µÃÅ—Ç—å ‚Äì h√§ngen (Zustand)",
            "7.	—Å—Ç–∞–∫–∞ÃÅ–Ω ‚Äì das Glas",
            "8.	—Ç–∞—Ä–µÃÅ–ª–∫–∞ ‚Äì der Teller",
            "9.	–≤–∞ÃÅ–∑–∞ ‚Äì die Vase",
            "10.	–∫–Ω–∏ÃÅ–≥–∞ ‚Äì das Buch",
            "11.	–∫–æ–≤—ë—Ä ‚Äì der Teppich",
            "12.	–Ω–æ—É—Ç–±—ÉÃÅ–∫ ‚Äì der Laptop",
            "13.	–∫–∞—Ä—Ç–∏ÃÅ–Ω–∞ ‚Äì das Bild / das Gem√§lde",
            "14.	—Å—Ç–µ–Ω–∞ÃÅ ‚Äì die Wand",
            "15.	—Å—Ç–æ–ª ‚Äì der Tisch",
            "16.	–ø–æ–ª ‚Äì der Fu√üboden",
            "17.	–ø–æÃÅ–ª–∫–∞ ‚Äì das Regal / das Wandbrett",
            "18.	—à–∫–∞—Ñ ‚Äì der Schrank",
            "19.	–ø–∞–ª—å—Ç–æÃÅ ‚Äì der Mantel",
            "20.	—èÃÅ–±–ª–æ–∫–æ ‚Äì der Apfel",
            "21.	–º—è—á ‚Äì der Ball",
            "22.	–º–∞—à–∏ÃÅ–Ω–∞ ‚Äì das Auto",
            "23.	—á–µ–ª–æ–≤–µÃÅ–∫ ‚Äì der Mensch",
            "24.	–ª–∞ÃÅ–º–ø–∞ ‚Äì die Lampe",
            "25.	—Å—ÉÃÅ–º–∫–∞ ‚Äì die Tasche",
            "26.	—á–∞—Å—ãÃÅ ‚Äì die Uhr",
            "27.	—á–∞ÃÅ—à–∫–∞ ‚Äì die Tasse",
            "28.	—Ü–≤–µ—Ç–æÃÅ–∫ ‚Äì die Blume",
            "29.	–¥–µÃÅ—Ä–µ–≤–æ ‚Äì der Baum",
            "30.	—Ä—ÉÃÅ—á–∫–∞ ‚Äì der Stift / der Kugelschreiber",
            "31.	–±—É—Ç—ãÃÅ–ª–∫–∞ ‚Äì die Flasche",
            "32.	–∑–æ–Ω—Ç ‚Äì der Regenschirm",
            "33.	–ø–∞ÃÅ—Å–ø–æ—Ä—Ç ‚Äì der Pass",
            "34.	–ª–æÃÅ–∂–∫–∞ ‚Äì der L√∂ffel",
            "35.	–≥–∞–∑–µÃÅ—Ç–∞ ‚Äì die Zeitung"
        ];

        // --- Parser ---
        // Wandelt die Liste in ein Objekt-Array um
        const vocabulary = rawVocabulary.map(item => {
            // Entferne Nummerierung am Anfang (z.B. "1. ")
            let cleanItem = item.replace(/^\d+\.\s+/, '');
            
            // Trenne Russisch und Deutsch am "‚Äì" (Gedankenstrich) oder "-"
            let parts = cleanItem.split(/[‚Äì-]/); 
            
            let front = parts[0].trim();
            let back = parts[1] ? parts[1].trim() : "";
            let backNote = "";

            // Pr√ºfen, ob eine Klammerbemerkung im deutschen Teil existiert
            // z.B. "h√§ngen (Aktion: aufh√§ngen)"
            // Wir trennen das Wort von der Notiz f√ºr sch√∂nere Darstellung
            const noteMatch = back.match(/(.*)\s+(\(.*\))$/);
            if (noteMatch) {
                back = noteMatch[1];
                backNote = noteMatch[2].replace(/[()]/g, ''); // Klammern entfernen f√ºr saubere Anzeige
            }

            return {
                front: front,
                back: back,
                frontNote: "", // In dieser Liste gibt es keine expliziten Front-Notizen
                backNote: backNote
            };
        });

        // --- State Management ---
        let currentStack = [...vocabulary]; // Kopie f√ºr das Mischen
        let currentIndex = 0;
        let isFlipped = false;

        // --- DOM Elemente ---
        const cardElement = document.getElementById('flashcard');
        const frontText = document.getElementById('front-text');
        const frontNote = document.getElementById('front-note');
        const backText = document.getElementById('back-text');
        const backNote = document.getElementById('back-note');
        
        const currentIndexDisplay = document.getElementById('current-index');
        const totalCountDisplay = document.getElementById('total-count');
        
        const btnPrev = document.getElementById('btn-prev');
        const btnNext = document.getElementById('btn-next');
        const btnReset = document.getElementById('btn-reset');
        const btnShuffle = document.getElementById('btn-shuffle');

        // --- Funktionen ---

        function updateDisplay() {
            const cardData = currentStack[currentIndex];
            
            // Text setzen
            frontText.textContent = cardData.front;
            frontNote.textContent = cardData.frontNote;
            backText.textContent = cardData.back;
            backNote.textContent = cardData.backNote;

            // Schriftgr√∂√üe anpassen f√ºr lange W√∂rter
            adjustFontSize(frontText, cardData.front);
            adjustFontSize(backText, cardData.back);

            // Fortschritt
            currentIndexDisplay.textContent = currentIndex + 1;
            totalCountDisplay.textContent = currentStack.length;

            // Flip zur√ºcksetzen, wenn man die Karte wechselt
            if (isFlipped) {
                cardElement.classList.remove('is-flipped');
                isFlipped = false;
            }

            // Button States
            btnPrev.disabled = currentIndex === 0;
            btnNext.disabled = currentIndex === currentStack.length - 1;
        }

        function adjustFontSize(element, text) {
            // Einfache Heuristik: Wenn Text l√§nger als 20 Zeichen, Schrift kleiner
            if (text.length > 25) {
                element.style.fontSize = "1.3rem";
            } else if (text.length > 15) {
                element.style.fontSize = "1.6rem";
            } else {
                element.style.fontSize = "2rem";
            }
        }

        function flipCard() {
            isFlipped = !isFlipped;
            cardElement.classList.toggle('is-flipped');
        }

        function nextCard() {
            if (currentIndex < currentStack.length - 1) {
                // Kurze Verz√∂gerung, damit man den Flip-Reset nicht sieht, 
                // falls die Karte gerade umgedreht ist.
                if (isFlipped) {
                    cardElement.classList.remove('is-flipped');
                    isFlipped = false;
                    setTimeout(() => {
                        currentIndex++;
                        updateDisplay();
                    }, 200); // Warte die halbe Flip-Animation ab
                } else {
                    currentIndex++;
                    updateDisplay();
                }
            }
        }

        function prevCard() {
            if (currentIndex > 0) {
                if (isFlipped) {
                    cardElement.classList.remove('is-flipped');
                    isFlipped = false;
                    setTimeout(() => {
                        currentIndex--;
                        updateDisplay();
                    }, 200);
                } else {
                    currentIndex--;
                    updateDisplay();
                }
            }
        }

        function resetStack() {
            // Geht zum Anfang des aktuellen Stapels (egal ob gemischt oder nicht)
            currentIndex = 0;
            isFlipped = false;
            cardElement.classList.remove('is-flipped');
            updateDisplay();
        }

        function shuffleStack() {
            // Fisher-Yates Shuffle
            for (let i = currentStack.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [currentStack[i], currentStack[j]] = [currentStack[j], currentStack[i]];
            }
            currentIndex = 0;
            isFlipped = false;
            cardElement.classList.remove('is-flipped');
            updateDisplay();
            
            // Visuelles Feedback f√ºr Button
            const originalText = btnShuffle.innerText;
            btnShuffle.innerText = "Gemischt!";
            setTimeout(() => btnShuffle.innerText = originalText, 1000);
        }

        // --- Event Listener ---

        // Klick auf Karte / Szene
        document.querySelector('.scene').addEventListener('click', flipCard);

        // Buttons
        btnNext.addEventListener('click', nextCard);
        btnPrev.addEventListener('click', prevCard);
        btnReset.addEventListener('click', resetStack);
        btnShuffle.addEventListener('click', shuffleStack);

        // Tastatursteuerung
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'Enter') {
                e.preventDefault(); // Verhindert Scrollen bei Leertaste
                flipCard();
            } else if (e.code === 'ArrowRight') {
                nextCard();
            } else if (e.code === 'ArrowLeft') {
                prevCard();
            } else if (e.code === 'Home') {
                resetStack();
            }
        });

        // --- Initialisierung ---
        updateDisplay();

    </script>
</body>
</html>